'use babel';
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Command = require('../Command');

var _Command2 = _interopRequireDefault(_Command);

var _Util = require('../../Util');

var _discord = require('discord.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Function.prototype.$asyncbind = function $asyncbind(self, catcher) {
	"use strict";

	if (!Function.prototype.$asyncbind) {
		Object.defineProperty(Function.prototype, "$asyncbind", {
			value: $asyncbind,
			enumerable: false,
			configurable: true,
			writable: true
		});
	}

	if (!$asyncbind.trampoline) {
		$asyncbind.trampoline = function trampoline(t, x, s, e, u) {
			return function b(q) {
				while (q) {
					if (q.then) {
						q = q.then(b, e);
						return u ? undefined : q;
					}

					try {
						if (q.pop) {
							if (q.length) return q.pop() ? x.call(t) : q;
							q = s;
						} else q = q.call(t);
					} catch (r) {
						return e(r);
					}
				}
			};
		};
	}

	if (!$asyncbind.LazyThenable) {
		$asyncbind.LazyThenable = function () {
			function isThenable(obj) {
				return obj && obj instanceof Object && typeof obj.then === "function";
			}

			function resolution(p, r, how) {
				try {
					var x = how ? how(r) : r;
					if (p === x) return p.reject(new TypeError("Promise resolution loop"));

					if (isThenable(x)) {
						x.then(function (y) {
							resolution(p, y);
						}, function (e) {
							p.reject(e);
						});
					} else {
						p.resolve(x);
					}
				} catch (ex) {
					p.reject(ex);
				}
			}

			function Chained() {}

			;
			Chained.prototype = {
				resolve: _unchained,
				reject: _unchained,
				then: thenChain
			};

			function _unchained(v) {}

			function thenChain(res, rej) {
				this.resolve = res;
				this.reject = rej;
			}

			function then(res, rej) {
				var chain = new Chained();

				try {
					this._resolver(function (value) {
						return isThenable(value) ? value.then(res, rej) : resolution(chain, value, res);
					}, function (ex) {
						resolution(chain, ex, rej);
					});
				} catch (ex) {
					resolution(chain, ex, rej);
				}

				return chain;
			}

			function Thenable(resolver) {
				this._resolver = resolver;
				this.then = then;
			}

			;

			Thenable.resolve = function (v) {
				return Thenable.isThenable(v) ? v : {
					then: function then(resolve) {
						return resolve(v);
					}
				};
			};

			Thenable.isThenable = isThenable;
			return Thenable;
		}();

		$asyncbind.EagerThenable = $asyncbind.Thenable = ($asyncbind.EagerThenableFactory = function (tick) {
			tick = tick || typeof process === "object" && process.nextTick || typeof setImmediate === "function" && setImmediate || function (f) {
				setTimeout(f, 0);
			};

			var soon = function () {
				var fq = [],
				    fqStart = 0,
				    bufferSize = 1024;

				function callQueue() {
					while (fq.length - fqStart) {
						fq[fqStart]();
						fq[fqStart++] = undefined;

						if (fqStart === bufferSize) {
							fq.splice(0, bufferSize);
							fqStart = 0;
						}
					}
				}

				return function (fn) {
					fq.push(fn);
					if (fq.length - fqStart === 1) tick(callQueue);
				};
			}();

			function Zousan(func) {
				if (func) {
					var me = this;
					func(function (arg) {
						me.resolve(arg);
					}, function (arg) {
						me.reject(arg);
					});
				}
			}

			Zousan.prototype = {
				resolve: function resolve(value) {
					if (this.state !== undefined) return;
					if (value === this) return this.reject(new TypeError("Attempt to resolve promise with self"));
					var me = this;

					if (value && (typeof value === "function" || typeof value === "object")) {
						try {
							var first = 0;
							var then = value.then;

							if (typeof then === "function") {
								then.call(value, function (ra) {
									if (!first++) {
										me.resolve(ra);
									}
								}, function (rr) {
									if (!first++) {
										me.reject(rr);
									}
								});
								return;
							}
						} catch (e) {
							if (!first) this.reject(e);
							return;
						}
					}

					this.state = STATE_FULFILLED;
					this.v = value;
					if (me.c) soon(function () {
						for (var n = 0, l = me.c.length; n < l; n++) STATE_FULFILLED(me.c[n], value);
					});
				},
				reject: function reject(reason) {
					if (this.state !== undefined) return;
					this.state = STATE_REJECTED;
					this.v = reason;
					var clients = this.c;
					if (clients) soon(function () {
						for (var n = 0, l = clients.length; n < l; n++) STATE_REJECTED(clients[n], reason);
					});
				},
				then: function then(onF, onR) {
					var p = new Zousan();
					var client = {
						y: onF,
						n: onR,
						p: p
					};

					if (this.state === undefined) {
						if (this.c) this.c.push(client);else this.c = [client];
					} else {
						var s = this.state,
						    a = this.v;
						soon(function () {
							s(client, a);
						});
					}

					return p;
				}
			};

			function STATE_FULFILLED(c, arg) {
				if (typeof c.y === "function") {
					try {
						var yret = c.y.call(undefined, arg);
						c.p.resolve(yret);
					} catch (err) {
						c.p.reject(err);
					}
				} else c.p.resolve(arg);
			}

			function STATE_REJECTED(c, reason) {
				if (typeof c.n === "function") {
					try {
						var yret = c.n.call(undefined, reason);
						c.p.resolve(yret);
					} catch (err) {
						c.p.reject(err);
					}
				} else c.p.reject(reason);
			}

			Zousan.resolve = function (val) {
				if (val && val instanceof Zousan) return val;
				var z = new Zousan();
				z.resolve(val);
				return z;
			};

			Zousan.reject = function (err) {
				if (err && err instanceof Zousan) return err;
				var z = new Zousan();
				z.reject(err);
				return z;
			};

			Zousan.version = "2.3.2-nodent";
			return Zousan;
		})();
	}

	var resolver = this;

	switch (catcher) {
		case true:
			return new $asyncbind.Thenable(boundThen);

		case 0:
			return new $asyncbind.LazyThenable(boundThen);

		case undefined:
			boundThen.then = boundThen;
			return boundThen;

		default:
			return function () {
				try {
					return resolver.apply(self, arguments);
				} catch (ex) {
					return catcher(ex);
				}
			};
	}

	function boundThen() {
		return resolver.apply(self, arguments);
	}
};

class Help extends _Command2.default {
	constructor(bot) {
		super(bot, {
			name: 'help',
			description: 'Provides information on bot commands',
			aliases: [],
			usage: `<prefix>help [command]`,
			extraHelp: 'Will DM bot command help information to the user to keep clutter down in guild channels. If you use the help command from within a DM you will only receive information for the commands you can use within the DM. If you want help with commands usable in a guild, call the help command in a guild channel. You will receive a list of the commands that you have permissions/roles for in that channel.',
			group: 'base'
		});
	}

	action(message, args) {
		return new Promise(function ($return, $error) {
			var dm, mentionName, preText, postText, usableCommands, widest;
			let command, output, embed, outMessage;

			if (this.bot.selfbot) message.delete();
			dm = message.channel.type === 'dm' || message.channel.type === 'group';
			mentionName = `@${ this.bot.user.username }#${ this.bot.user.discriminator }`;

			output = '';
			embed = new _discord.RichEmbed();

			if (!args[0]) {
				preText = `Available commands in ${ dm ? 'this DM' : message.channel }\n\`\`\`ldif\n`;
				postText = `\`\`\`Use \`<prefix>help <command>\` ${ this.bot.selfbot ? '' : `or \`${ mentionName } help <command>\` ` }for more information.\n\n`;
				usableCommands = this.bot.commands[dm ? 'filterDMUsable' : 'filterGuildUsable'](this.bot, message).filter(c => !c.hidden);
				widest = usableCommands.map(c => c.name.length).reduce((a, b) => Math.max(a, b));

				let commandList = usableCommands.map(c => `${ (0, _Util.padRight)(c.name, widest + 1) }: ${ c.description }`).sort().join('\n');

				output = preText + commandList + postText;
				if (output.length >= 1024) {
					commandList = '';
					let mappedCommands = usableCommands.map(c => (0, _Util.padRight)(c.name, widest + 2)).sort();
					for (let i = 0; i <= mappedCommands.length; i++) {
						commandList += mappedCommands[i];
						if ((i + 1) % 3 === 0) commandList += '\n';
					}
					output = preText + commandList + postText;
				}
			} else {
				command = this.bot.commands[dm ? 'filterDMUsable' : 'filterGuildUsable'](this.bot, message).filter(c => c.name === args[0] || c.aliases.includes(args[0])).first();

				if (!command) output = `A command by that name could not be found or you do\n` + `not have permissions to view it in this guild or channel`;else output = '```ldif\n' // eslint-disable-line prefer-template
				+ `Command: ${ command.name }\n` + `Description: ${ command.description }\n` + (command.aliases.length > 0 ? `Aliases: ${ command.aliases.join(', ') }\n` : '') + `Usage: ${ command.usage }\n` + (command.extraHelp ? `\n${ command.extraHelp }` : '') + '\n```';
			}

			output = dm ? output.replace(/<prefix>/g, '') : output.replace(/<prefix>/g, this.bot.getPrefix(message.guild) || '');

			embed.setColor(11854048).setDescription(output);

			if (!dm && !this.bot.selfbot && command) message.reply(`Sent you a DM with command help information.`);
			if (!dm && !this.bot.selfbot && !command) message.reply(`Sent you a DM with a list of commands.`);
			if (this.bot.selfbot) {
				return message.channel.sendEmbed(embed).then(function ($await_2) {
					outMessage = $await_2;
					return $If_1.call(this);
				}.$asyncbind(this, $error), $error);
			} else {
				message.author.sendEmbed(embed);

				return $If_1.call(this);
			}
			function $If_1() {
				if (outMessage) outMessage.delete(30e3);
				return $return();
			}
		}.$asyncbind(this));
	}
}
exports.default = Help;