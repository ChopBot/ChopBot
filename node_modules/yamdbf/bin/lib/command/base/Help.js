'use babel';
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Command = require('../Command');

var _Command2 = _interopRequireDefault(_Command);

var _Util = require('../../Util');

var _discord = require('discord.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Function.prototype.$asyncbind = function anonymous(self, catcher) {
	var resolver = this;

	if (catcher === true) {
		if (!Function.prototype.$asyncbind.EagerThenable) Function.prototype.$asyncbind.EagerThenable = function factory(tick) {
			var _tasks = [];

			if (!tick) {
				try {
					tick = process.nextTick;
				} catch (ex) {
					tick = function tick(p) {
						setTimeout(p, 0);
					};
				}
			}

			function _untask() {
				for (var i = 0; i < _tasks.length; i += 2) {
					var t = _tasks[i + 1],
					    r = _tasks[i];

					for (var j = 0; j < t.length; j++) t[j].call(null, r);
				}

				_tasks = [];
			}

			function isThenable(obj) {
				return obj && obj instanceof Object && typeof obj.then === 'function';
			}

			function EagerThenable(resolver) {
				function done(inline) {
					var w;
					if (_sync || phase < 0 || (w = _thens[phase]).length === 0) return;

					_tasks.push(result, w);

					_thens = [[], []];
					if (_tasks.length === 2) inline ? _untask() : tick(_untask);
				}

				function resolveThen(x) {
					if (phase >= 0) return;
					if (isThenable(x)) return x.then(resolveThen, rejectThen);
					phase = 0;
					result = x;
					done(true);
				}

				function rejectThen(x) {
					if (phase >= 0) return;
					if (isThenable(x)) return x.then(resolveThen, rejectThen);
					phase = 1;
					result = x;
					done(true);
				}

				function settler(resolver, rejecter) {
					_thens[0].push(resolver);

					_thens[1].push(rejecter);

					done();
				}

				function toString() {
					return 'EagerThenable{' + {
						'-1': 'pending',
						0: 'resolved',
						1: 'rejected'
					}[phase] + '}=' + result.toString();
				}

				function guard() {
					try {
						resolver.call(null, resolveThen, rejectThen);
					} catch (ex) {
						rejectThen(ex);
					}
				}

				this.then = settler;
				this.toString = toString;
				var _thens = [[], []],
				    _sync = true,
				    phase = -1,
				    result;
				guard();
				_sync = false;
				done();
			}

			EagerThenable.resolve = function (v) {
				return isThenable(v) ? v : {
					then: function then(resolve, reject) {
						return resolve(v);
					}
				};
			};

			return EagerThenable;
		}();
		return new Function.prototype.$asyncbind.EagerThenable(boundThen);
	}

	if (catcher) {
		if (Function.prototype.$asyncbind.wrapAsyncStack) catcher = Function.prototype.$asyncbind.wrapAsyncStack(catcher);
		return then;
	}

	function then(result, error) {
		try {
			return result && result instanceof Object && typeof result.then === 'function' ? result.then(then, catcher) : resolver.call(self, result, error || catcher);
		} catch (ex) {
			return (error || catcher)(ex);
		}
	}

	function boundThen(result, error) {
		return resolver.call(self, result, error);
	}

	boundThen.then = boundThen;
	return boundThen;
};

class Help extends _Command2.default {
	constructor(bot) {
		super(bot, {
			name: 'help',
			description: 'Provides information on bot commands',
			aliases: [],
			usage: `<prefix>help [command]`,
			extraHelp: 'Will DM bot command help information to the user to keep clutter down in guild channels. If you use the help command from within a DM you will only receive information for the commands you can use within the DM. If you want help with commands usable in a guild, call the help command in a guild channel. You will receive a list of the commands that you have permissions/roles for in that channel.',
			group: 'base'
		});
	}

	action(message, args) {
		return new Promise(function ($return, $error) {
			var dm, mentionName, widest, filter;
			let usableCommands, command, output, embed, outMessage;

			if (this.bot.selfbot) message.delete();
			dm = message.channel.type === 'dm' || message.channel.type === 'group';
			mentionName = `@${ this.bot.user.username }#${ this.bot.user.discriminator }`;

			output = '';
			embed = new _discord.RichEmbed();

			if (!args[0]) {
				if (!dm) {
					output += `Available commands in ${ message.channel }\n\`\`\`ldif\n`;
					usableCommands = this.bot.commands.filterGuildUsable(this.bot, message);
				} else {
					output += `Available commands in this DM:\n\`\`\`ldif\n`;
					usableCommands = this.bot.commands.filterDMUsable(this.bot, message);
				}

				widest = usableCommands.map(c => c.name.length).reduce((a, b) => Math.max(a, b));

				output += usableCommands.map(c => `${ (0, _Util.padRight)(c.name, widest + 1) }: ${ c.description }`).sort().join('\n');

				output += `\`\`\`Use \`<prefix>help <command>\` ${ this.bot.selfbot ? '' : `or \`${ mentionName } help <command>\` ` }for more information.\n\n`;
			} else {
				filter = c => c.name === args[0] || c.aliases.includes(args[0]);

				if (!dm) command = this.bot.commands.filterGuildUsable(this.bot, message).filter(filter).first();else command = this.bot.commands.filterDMHelp(this.bot, message).filter(filter).first();

				if (!command) output = `A command by that name could not be found or you do\n` + `not have permissions to view it in this guild or channel`;else output = '```ldif\n' // eslint-disable-line prefer-template
				+ `Command: ${ command.name }\n` + `Description: ${ command.description }\n` + (command.aliases.length > 0 ? `Aliases: ${ command.aliases.join(', ') }\n` : '') + `Usage: ${ command.usage }\n` + (command.extraHelp ? `\n${ command.extraHelp }` : '') + '\n```';
			}

			output = dm ? output.replace(/<prefix>/g, '') : output.replace(/<prefix>/g, this.bot.getPrefix(message.guild) || '');

			embed.setColor(11854048).setDescription(output);

			if (!dm && !this.bot.selfbot && command) message.reply(`Sent you a DM with help information.`);
			if (!dm && !this.bot.selfbot && !command) message.reply(`Sent you a DM with information.`);

			function $IfStatement_1() {

				if (this.bot.selfbot) outMessage.delete(30e3);
				return $return();
			}

			if (this.bot.selfbot) {
				return message.channel.sendEmbed(embed).then(function ($await_2) {
					outMessage = $await_2;
					return $IfStatement_1.call(this);
				}.$asyncbind(this, $error), $error);
			} else {
				message.author.sendEmbed(embed);return $IfStatement_1.call(this);
			}
		}.$asyncbind(this));
	}
}
exports.default = Help;