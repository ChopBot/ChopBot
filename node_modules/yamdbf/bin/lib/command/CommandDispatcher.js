'use babel';
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _performanceNow = require('performance-now');

var _performanceNow2 = _interopRequireDefault(_performanceNow);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Function.prototype.$asyncbind = function anonymous(self, catcher) {
	var resolver = this;

	if (catcher === true) {
		if (!Function.prototype.$asyncbind.EagerThenable) Function.prototype.$asyncbind.EagerThenable = function factory(tick) {
			var _tasks = [];

			if (!tick) {
				try {
					tick = process.nextTick;
				} catch (ex) {
					tick = function tick(p) {
						setTimeout(p, 0);
					};
				}
			}

			function _untask() {
				for (var i = 0; i < _tasks.length; i += 2) {
					var t = _tasks[i + 1],
					    r = _tasks[i];

					for (var j = 0; j < t.length; j++) t[j].call(null, r);
				}

				_tasks = [];
			}

			function isThenable(obj) {
				return obj && obj instanceof Object && typeof obj.then === 'function';
			}

			function EagerThenable(resolver) {
				function done(inline) {
					var w;
					if (_sync || phase < 0 || (w = _thens[phase]).length === 0) return;

					_tasks.push(result, w);

					_thens = [[], []];
					if (_tasks.length === 2) inline ? _untask() : tick(_untask);
				}

				function resolveThen(x) {
					if (phase >= 0) return;
					if (isThenable(x)) return x.then(resolveThen, rejectThen);
					phase = 0;
					result = x;
					done(true);
				}

				function rejectThen(x) {
					if (phase >= 0) return;
					if (isThenable(x)) return x.then(resolveThen, rejectThen);
					phase = 1;
					result = x;
					done(true);
				}

				function settler(resolver, rejecter) {
					_thens[0].push(resolver);

					_thens[1].push(rejecter);

					done();
				}

				function toString() {
					return 'EagerThenable{' + {
						'-1': 'pending',
						0: 'resolved',
						1: 'rejected'
					}[phase] + '}=' + result.toString();
				}

				function guard() {
					try {
						resolver.call(null, resolveThen, rejectThen);
					} catch (ex) {
						rejectThen(ex);
					}
				}

				this.then = settler;
				this.toString = toString;
				var _thens = [[], []],
				    _sync = true,
				    phase = -1,
				    result;
				guard();
				_sync = false;
				done();
			}

			EagerThenable.resolve = function (v) {
				return isThenable(v) ? v : {
					then: function then(resolve, reject) {
						return resolve(v);
					}
				};
			};

			return EagerThenable;
		}();
		return new Function.prototype.$asyncbind.EagerThenable(boundThen);
	}

	if (catcher) {
		if (Function.prototype.$asyncbind.wrapAsyncStack) catcher = Function.prototype.$asyncbind.wrapAsyncStack(catcher);
		return then;
	}

	function then(result, error) {
		try {
			return result && result instanceof Object && typeof result.then === 'function' ? result.then(then, catcher) : resolver.call(self, result, error || catcher);
		} catch (ex) {
			return (error || catcher)(ex);
		}
	}

	function boundThen(result, error) {
		return resolver.call(self, result, error);
	}

	boundThen.then = boundThen;
	return boundThen;
};

/**
 * Handles dispatching commands
 * @class CommandDispatcher
 * @param {Bot} bot - Bot instance
 */
class CommandDispatcher {
	constructor(bot) {
		/** @type {Bot} */
		this._bot = bot;

		// Register message listener
		if (!this._bot.passive) this._bot.on('message', message => this.handleMessage(message));
	}

	/**
  * Determine if message is a valid command call and send to {@link CommandDispatcher#dispatch}
  * @memberof CommandDispatcher
  * @instance
  * @param {external:Message} message - Discord.js message object
  * @returns {*}
  */
	handleMessage(message) {
		return new Promise(function ($return, $error) {
			var dispatchStart, dispatchEnd;
			let config, original, command, mentions, args, content, dm, guildStorage, missingPermissions;
			dispatchStart = (0, _performanceNow2.default)();

			config = this._bot.config;
			if (this._bot.selfbot && message.author !== this._bot.user) return $return(false);
			if (message.author.bot) return $return(false);
			original = message.content;

			({ command, mentions, args, content, dm } = this.processContent(message));
			message.content = content;

			if (dm && !command && !this._bot.selfbot) {
				return $return(this.commandNotFoundError(message));
			} else if (!command) {
				message.content = original;
				return $return(false);
			}

			guildStorage = !dm ? this._bot.guildStorages.get(message.guild) : null;
			if (!dm && guildStorage.settingExists('disabledGroups') && guildStorage.getSetting('disabledGroups').includes(command.group)) return $return(false);
			if (command.ownerOnly && !config.owner.includes(message.author.id)) return $return(false);
			if (dm && command.guildOnly) return $return(this.guildOnlyError(message));

			missingPermissions = this.checkPermissions(dm, message, command);
			if (missingPermissions.length > 0) return $return(this.missingPermissionsError(missingPermissions, message));

			if (!this.checkLimiter(dm, message, command)) return $return(this.failedLimitorError(message, command));

			if (!this.hasRoles(dm, message, command)) return $return(this.missingRolesError(message, command));
			if (guildStorage) message.guild.storage = guildStorage;

			return this.dispatch(command, message, args, mentions, original).catch(console.error).then(function ($await_2) {
				dispatchEnd = (0, _performanceNow2.default)() - dispatchStart;


				/**
     * Emitted whenever a command is successfully called
     * @memberof Bot
     * @instance
     * @event event:command
     * @param {string} name - Name of the called command
     * @param {args[]} args - Args passed to the called command
     * @param {string} original - Original content of the message that called the command
     * @param {number} execTime - Time command took to execute
     * @param {external:Message} message - Message that triggered the command
     */
				return $return(this._bot.emit('command', command.name, args, original, dispatchEnd, message));
			}.$asyncbind(this, $error), $error);
		}.$asyncbind(this));
	}

	/**
  * Processes message content, finding the command to execute and creating an
  * object containing the found command, mentions, args, processed content, and
  * if the message is a DM
  * @memberof CommandDispatcher
  * @instance
  * @param {external:Message} message - Discord.js message object
  * @returns {Object}
  */
	processContent(message) {
		let dm = message.channel.type === 'dm' || message.channel.type === 'group';
		let mentions;
		let duplicateMention;
		let regexMentions = message.content.match(/<@!?\d+>/g);
		if (regexMentions && regexMentions.length > 1) {
			let firstMention = regexMentions.shift();
			duplicateMention = regexMentions.includes(firstMention);
		}
		mentions = message.mentions.users.array().sort((a, b) => message.content.indexOf(a.id) - message.content.indexOf(b.id));

		let botMention = /^<@!?\d+>.+/.test(message.content) && mentions[0].id === this._bot.user.id && !this._bot.selfbot;

		let content;
		if (botMention && !duplicateMention) {
			content = message.content.replace(/<@!?\d+>/g, '').trim();
			mentions = mentions.slice(1);
		} else if (botMention && duplicateMention) {
			content = message.content.replace(/<@!?\d+>/g, '').trim();
		} else if (!dm && (message.content.startsWith(this._bot.getPrefix(message.guild)) || !this._bot.getPrefix(message.guild))) {
			content = message.content.slice(this._bot.getPrefix(message.guild) ? this._bot.getPrefix(message.guild).length : 0).replace(/<@!?\d+>/g, '').trim();
		} else if (dm) {
			if (/<@!?\d+>.+/.test(message.content)) {
				content = message.content.replace(/<@!?\d+>/g, '').trim();
				mentions = mentions.slice(1);
			} else {
				content = message.content.trim();
			}
		} else {
			return false;
		}
		content = content.replace(/ +/g, ' ');

		let commandName = content.split(' ')[0];
		let command = this._bot.commands.findByNameOrAlias(commandName);

		let args = content.split(' ').slice(1).join(' ').split(command ? command.argOpts.separator : ' ').map(a => !isNaN(a) && command && !command.argOpts.stringArgs ? parseFloat(a) : a).map(a => typeof a === 'string' ? a.trim() : a);

		return { command: command, mentions: mentions, args: args, content: content, dm: dm };
	}

	/**
  * Get a list of missing permissions for the command caller for the
  * given command, if any
  * @memberof CommandDispatcher
  * @instance
  * @param {boolean} dm - Whether the message is a DM
  * @param {external:Message} message - Discord.js message object
  * @param {Command} command - Command found by the dispatcher
  * @returns {external:PermissionResolvable[]}
  */
	checkPermissions(dm, message, command) {
		return this._bot.selfbot || dm ? [] : command.permissions.filter(a => !message.channel.permissionsFor(message.author).hasPermission(a));
	}

	/**
  * Check of the command caller has roles that pass the command
  * limiter set by the guild admins if the command is called
  * within a guild
  * @memberof CommandDispatcher
  * @instance
  * @param {boolean} dm - Whether the message is a DM
  * @param {external:Message} message - Discord.js message object
  * @param {Command} command - Command found by the dispatcher
  * @returns {boolean}
  */
	checkLimiter(dm, message, command) {
		if (dm || this._bot.selfbot) return true;
		let storage = this._bot.guildStorages.get(message.guild);
		let limitedCommands = storage.getSetting('limitedCommands') || {};
		if (!limitedCommands[command.name]) return true;
		if (limitedCommands[command.name].length === 0) return true;
		return message.member.roles.filter(role => limitedCommands[command.name].includes(role.id)).size > 0;
	}

	/**
  * Checks if the command caller has roles for the given command
  * @memberof CommandDispatcher
  * @instance
  * @param {boolean} dm - Whether the message is a DM
  * @param {external:Message} message - Discord.js message object
  * @param {Command} command - Command found by the dispatcher
  * @returns {boolean}
  */
	hasRoles(dm, message, command) {
		return this._bot.selfbot || command.roles.length === 0 || dm || message.member.roles.filter(role => command.roles.includes(role.name)).size > 0;
	}

	/**
  * Send a 'command not found' error message to the channel
  * @memberof CommandDispatcher
  * @instance
  * @param {external:Message} message - Discord.js message object
  * @returns {Promise<external:Message>}
  */
	commandNotFoundError(message) {
		return message.channel.sendMessage(`` + `Sorry, I didn't recognize any command in your message.\n` + `Try saying "help" to view a list of commands you can use in ` + `this DM, or try calling the\nhelp command in a server channel ` + `to see what commands you can use there!`);
	}

	/**
  * Send a 'guild only' error message to the channel
  * @memberof CommandDispatcher
  * @instance
  * @param {external:Message} message - Discord.js message object
  * @returns {Promise<external:Message>}
  */
	guildOnlyError(message) {
		return message.channel.sendMessage(`` + `That command is for servers only. Try saying "help" to see a ` + `list of commands you can use in this DM`);
	}

	/**
  * Send a 'missing permissions' error message to the channel
  * @memberof CommandDispatcher
  * @instance
  * @param {external:PermissionResolvable[]} missing - Array of missing permissions
  * @param {external:Message} message - Discord.js message object
  * @returns {Promise<external:Message>}
  */
	missingPermissionsError(missing, message) {
		return message[`${ this._bot.selfbot ? 'channel' : 'author' }`].sendMessage(`` + `**You're missing the following permission` + `${ missing.length > 1 ? 's' : '' } ` + `for that command:**\n\`\`\`css\n` + `${ missing.join(', ') }\n\`\`\``).then(response => {
			if (this._bot.selfbot) response.delete(10e3);
		});
	}

	/**
  * Send a 'missing roles' error message to the channel
  * @memberof CommandDispatcher
  * @instance
  * @param {external:Message} message - Discord.js message object
  * @param {Command} command - Command found by the dispatcher
  * @returns {Promise<external:Message>}
  */
	missingRolesError(message, command) {
		return message[`${ this._bot.selfbot ? 'channel' : 'author' }`].sendMessage(`` + `**You must have ${ command.roles.length > 1 ? 'one of the following roles' : 'the following role' }` + ` to use that command:**\n\`\`\`css\n` + `${ command.roles.join(', ') }\n\`\`\``).then(response => {
			if (this._bot.selfbot) response.delete(10e3);
		});
	}

	/**
  * Send a 'missing roles for role-limited command' error
  * message to the channel
  * @memberof CommandDispatcher
  * @instance
  * @param {external:Message} message - Discord.js message object
  * @param {Command} command - Command found by the dispatcher
  * @returns {Promise<external:Message>}
  */
	failedLimitorError(message, command) {
		const storage = this._bot.guildStorages.get(message.guild);
		let limitedCommands = storage.getSetting('limitedCommands');
		let roles = limitedCommands[command.name];
		return message[`${ this._bot.selfbot ? 'channel' : 'author' }`].send(`` + `**You must have ${ roles.length > 1 ? 'one of the following roles' : 'the following role' }` + ` to use that command:**\n\`\`\`css\n` + `${ message.guild.roles.filter(role => roles.includes(role.id)).map(role => role.name).join(', ') }\n\`\`\``);
	}

	/**
  * Pass the necessary items to the found Command's {@link Command#action} method
  * @memberof CommandDispatcher
  * @instance
  * @param {Command} command - The command found by the dispatcher
  * @param {external:Message} message - Discord.js message object
  * @param {args[]} args - An array containing the args parsed from the command calling message
  * @param {external:User[]} mentions - An array containing the Discord.js User
  * objects parsed from the mentions contained in a message
  * @param {string} original - The original raw content of the message that called the command
  * @returns {Promise<*>}
  */
	dispatch(command, message, args, mentions, original) {
		return new Promise(function ($return, $error) {
			return $return(new Promise((resolve, reject) => {
				try {
					const action = command.action(message, args, mentions, original);
					if (action instanceof Promise) action.then(resolve).catch(reject);else resolve(action);
				} catch (err) {
					reject(err);
				}
			}));
		}.$asyncbind(this));
	}
}
exports.default = CommandDispatcher;