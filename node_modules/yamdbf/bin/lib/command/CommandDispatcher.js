'use babel';
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _performanceNow = require('performance-now');

var _performanceNow2 = _interopRequireDefault(_performanceNow);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Function.prototype.$asyncbind = function $asyncbind(self, catcher) {
	"use strict";

	if (!Function.prototype.$asyncbind) {
		Object.defineProperty(Function.prototype, "$asyncbind", {
			value: $asyncbind,
			enumerable: false,
			configurable: true,
			writable: true
		});
	}

	if (!$asyncbind.trampoline) {
		$asyncbind.trampoline = function trampoline(t, x, s, e, u) {
			return function b(q) {
				while (q) {
					if (q.then) {
						q = q.then(b, e);
						return u ? undefined : q;
					}

					try {
						if (q.pop) {
							if (q.length) return q.pop() ? x.call(t) : q;
							q = s;
						} else q = q.call(t);
					} catch (r) {
						return e(r);
					}
				}
			};
		};
	}

	if (!$asyncbind.LazyThenable) {
		$asyncbind.LazyThenable = function () {
			function isThenable(obj) {
				return obj && obj instanceof Object && typeof obj.then === "function";
			}

			function resolution(p, r, how) {
				try {
					var x = how ? how(r) : r;
					if (p === x) return p.reject(new TypeError("Promise resolution loop"));

					if (isThenable(x)) {
						x.then(function (y) {
							resolution(p, y);
						}, function (e) {
							p.reject(e);
						});
					} else {
						p.resolve(x);
					}
				} catch (ex) {
					p.reject(ex);
				}
			}

			function Chained() {}

			;
			Chained.prototype = {
				resolve: _unchained,
				reject: _unchained,
				then: thenChain
			};

			function _unchained(v) {}

			function thenChain(res, rej) {
				this.resolve = res;
				this.reject = rej;
			}

			function then(res, rej) {
				var chain = new Chained();

				try {
					this._resolver(function (value) {
						return isThenable(value) ? value.then(res, rej) : resolution(chain, value, res);
					}, function (ex) {
						resolution(chain, ex, rej);
					});
				} catch (ex) {
					resolution(chain, ex, rej);
				}

				return chain;
			}

			function Thenable(resolver) {
				this._resolver = resolver;
				this.then = then;
			}

			;

			Thenable.resolve = function (v) {
				return Thenable.isThenable(v) ? v : {
					then: function then(resolve) {
						return resolve(v);
					}
				};
			};

			Thenable.isThenable = isThenable;
			return Thenable;
		}();

		$asyncbind.EagerThenable = $asyncbind.Thenable = ($asyncbind.EagerThenableFactory = function (tick) {
			tick = tick || typeof process === "object" && process.nextTick || typeof setImmediate === "function" && setImmediate || function (f) {
				setTimeout(f, 0);
			};

			var soon = function () {
				var fq = [],
				    fqStart = 0,
				    bufferSize = 1024;

				function callQueue() {
					while (fq.length - fqStart) {
						fq[fqStart]();
						fq[fqStart++] = undefined;

						if (fqStart === bufferSize) {
							fq.splice(0, bufferSize);
							fqStart = 0;
						}
					}
				}

				return function (fn) {
					fq.push(fn);
					if (fq.length - fqStart === 1) tick(callQueue);
				};
			}();

			function Zousan(func) {
				if (func) {
					var me = this;
					func(function (arg) {
						me.resolve(arg);
					}, function (arg) {
						me.reject(arg);
					});
				}
			}

			Zousan.prototype = {
				resolve: function resolve(value) {
					if (this.state !== undefined) return;
					if (value === this) return this.reject(new TypeError("Attempt to resolve promise with self"));
					var me = this;

					if (value && (typeof value === "function" || typeof value === "object")) {
						try {
							var first = 0;
							var then = value.then;

							if (typeof then === "function") {
								then.call(value, function (ra) {
									if (!first++) {
										me.resolve(ra);
									}
								}, function (rr) {
									if (!first++) {
										me.reject(rr);
									}
								});
								return;
							}
						} catch (e) {
							if (!first) this.reject(e);
							return;
						}
					}

					this.state = STATE_FULFILLED;
					this.v = value;
					if (me.c) soon(function () {
						for (var n = 0, l = me.c.length; n < l; n++) STATE_FULFILLED(me.c[n], value);
					});
				},
				reject: function reject(reason) {
					if (this.state !== undefined) return;
					this.state = STATE_REJECTED;
					this.v = reason;
					var clients = this.c;
					if (clients) soon(function () {
						for (var n = 0, l = clients.length; n < l; n++) STATE_REJECTED(clients[n], reason);
					});
				},
				then: function then(onF, onR) {
					var p = new Zousan();
					var client = {
						y: onF,
						n: onR,
						p: p
					};

					if (this.state === undefined) {
						if (this.c) this.c.push(client);else this.c = [client];
					} else {
						var s = this.state,
						    a = this.v;
						soon(function () {
							s(client, a);
						});
					}

					return p;
				}
			};

			function STATE_FULFILLED(c, arg) {
				if (typeof c.y === "function") {
					try {
						var yret = c.y.call(undefined, arg);
						c.p.resolve(yret);
					} catch (err) {
						c.p.reject(err);
					}
				} else c.p.resolve(arg);
			}

			function STATE_REJECTED(c, reason) {
				if (typeof c.n === "function") {
					try {
						var yret = c.n.call(undefined, reason);
						c.p.resolve(yret);
					} catch (err) {
						c.p.reject(err);
					}
				} else c.p.reject(reason);
			}

			Zousan.resolve = function (val) {
				if (val && val instanceof Zousan) return val;
				var z = new Zousan();
				z.resolve(val);
				return z;
			};

			Zousan.reject = function (err) {
				if (err && err instanceof Zousan) return err;
				var z = new Zousan();
				z.reject(err);
				return z;
			};

			Zousan.version = "2.3.2-nodent";
			return Zousan;
		})();
	}

	var resolver = this;

	switch (catcher) {
		case true:
			return new $asyncbind.Thenable(boundThen);

		case 0:
			return new $asyncbind.LazyThenable(boundThen);

		case undefined:
			boundThen.then = boundThen;
			return boundThen;

		default:
			return function () {
				try {
					return resolver.apply(self, arguments);
				} catch (ex) {
					return catcher(ex);
				}
			};
	}

	function boundThen() {
		return resolver.apply(self, arguments);
	}
};

/**
 * Handles dispatching commands
 * @class CommandDispatcher
 * @param {Bot} bot - Bot instance
 */
class CommandDispatcher {
	constructor(bot) {
		/** @type {Bot} */
		this._bot = bot;

		// Register message listener
		if (!this._bot.passive) this._bot.on('message', message => this.handleMessage(message));
	}

	/**
  * Determine if message is a valid command call and send to {@link CommandDispatcher#dispatch}
  * @memberof CommandDispatcher
  * @instance
  * @param {external:Message} message - Discord.js message object
  * @returns {*}
  */
	handleMessage(message) {
		return new Promise(function ($return, $error) {
			var dispatchStart, dispatchEnd;
			let config, original, command, mentions, args, content, dm, guildStorage, missingPermissions;
			dispatchStart = (0, _performanceNow2.default)();

			config = this._bot.config;
			if (this._bot.selfbot && message.author !== this._bot.user) return $return(false);
			if (message.author.bot) return $return(false);
			original = message.content;

			({ command, mentions, args, content, dm } = this.processContent(message));
			message.content = content;

			if (dm && !command && !this._bot.selfbot && this._bot.noCommandErr) {
				return $return(this.commandNotFoundError(message));
			} else if (!command) {
				message.content = original;
				return $return(false);
			}

			guildStorage = !dm ? this._bot.guildStorages.get(message.guild) : null;
			if (!dm && guildStorage.settingExists('disabledGroups') && guildStorage.getSetting('disabledGroups').includes(command.group)) return $return(false);
			if (command.ownerOnly && !config.owner.includes(message.author.id)) return $return(false);
			if (dm && command.guildOnly) return $return(this.guildOnlyError(message));

			missingPermissions = this.checkPermissions(dm, message, command);
			if (missingPermissions.length > 0) return $return(this.missingPermissionsError(missingPermissions, message));

			if (!this.checkLimiter(dm, message, command)) return $return(this.failedLimiterError(message, command));

			if (!this.hasRoles(dm, message, command)) return $return(this.missingRolesError(message, command));
			if (guildStorage) message.guild.storage = guildStorage;

			return this.dispatch(command, message, args, mentions, original).catch(console.error).then(function ($await_2) {
				dispatchEnd = (0, _performanceNow2.default)() - dispatchStart;


				/**
     * Emitted whenever a command is successfully called
     * @memberof Bot
     * @instance
     * @event event:command
     * @param {string} name - Name of the called command
     * @param {args[]} args - Args passed to the called command
     * @param {string} original - Original content of the message that called the command
     * @param {number} execTime - Time command took to execute
     * @param {external:Message} message - Message that triggered the command
     */
				return $return(this._bot.emit('command', command.name, args, original, dispatchEnd, message));
			}.$asyncbind(this, $error), $error);
		}.$asyncbind(this));
	}

	/**
  * Processes message content, finding the command to execute and creating an
  * object containing the found command, mentions, args, processed content, and
  * if the message is a DM
  * @memberof CommandDispatcher
  * @instance
  * @param {external:Message} message - Discord.js message object
  * @returns {Object}
  */
	processContent(message) {
		let dm = message.channel.type === 'dm' || message.channel.type === 'group';
		let mentions;
		let duplicateMention;
		let regexMentions = message.content.match(/<@!?\d+>/g);
		if (regexMentions && regexMentions.length > 1) {
			let firstMention = regexMentions.shift();
			duplicateMention = regexMentions.includes(firstMention);
		}
		mentions = message.mentions.users.array().sort((a, b) => message.content.indexOf(a.id) - message.content.indexOf(b.id));

		let botMention = /^<@!?\d+>.+/.test(message.content) && mentions[0].id === this._bot.user.id && !this._bot.selfbot;

		let content;
		if (botMention && !duplicateMention) {
			content = message.content.replace(/<@!?\d+>/g, '').trim();
			mentions = mentions.slice(1);
		} else if (botMention && duplicateMention) {
			content = message.content.replace(/<@!?\d+>/g, '').trim();
		} else if (!dm && (message.content.startsWith(this._bot.getPrefix(message.guild)) || !this._bot.getPrefix(message.guild))) {
			content = message.content.slice(this._bot.getPrefix(message.guild) ? this._bot.getPrefix(message.guild).length : 0).replace(/<@!?\d+>/g, '').trim();
		} else if (dm) {
			if (/<@!?\d+>.+/.test(message.content)) {
				content = message.content.replace(/<@!?\d+>/g, '').trim();
				mentions = mentions.slice(1);
			} else {
				content = message.content.trim();
			}
		} else {
			return false;
		}
		content = content.replace(/ +/g, ' ');

		let commandName = content.split(' ')[0];
		let command = this._bot.commands.findByNameOrAlias(commandName);

		let args = content.split(' ').slice(1).join(' ').split(command ? command.argOpts.separator : ' ').map(a => !isNaN(a) && command && !command.argOpts.stringArgs ? parseFloat(a) : a).map(a => typeof a === 'string' ? a.trim() : a).filter(a => a !== '' && !(typeof a !== 'string' && isNaN(a)));

		return { command: command, mentions: mentions, args: args, content: content, dm: dm };
	}

	/**
  * Get a list of missing permissions for the command caller for the
  * given command, if any
  * @memberof CommandDispatcher
  * @instance
  * @param {boolean} dm - Whether the message is a DM
  * @param {external:Message} message - Discord.js message object
  * @param {Command} command - Command found by the dispatcher
  * @returns {external:PermissionResolvable[]}
  */
	checkPermissions(dm, message, command) {
		return this._bot.selfbot || dm ? [] : command.permissions.filter(a => !message.channel.permissionsFor(message.author).hasPermission(a));
	}

	/**
  * Check of the command caller has roles that pass the command
  * limiter set by the guild admins if the command is called
  * within a guild
  * @memberof CommandDispatcher
  * @instance
  * @param {boolean} dm - Whether the message is a DM
  * @param {external:Message} message - Discord.js message object
  * @param {Command} command - Command found by the dispatcher
  * @returns {boolean}
  */
	checkLimiter(dm, message, command) {
		if (dm || this._bot.selfbot) return true;
		let storage = this._bot.guildStorages.get(message.guild);
		let limitedCommands = storage.getSetting('limitedCommands') || {};
		if (!limitedCommands[command.name]) return true;
		if (limitedCommands[command.name].length === 0) return true;
		return message.member.roles.filter(role => limitedCommands[command.name].includes(role.id)).size > 0;
	}

	/**
  * Checks if the command caller has roles for the given command
  * @memberof CommandDispatcher
  * @instance
  * @param {boolean} dm - Whether the message is a DM
  * @param {external:Message} message - Discord.js message object
  * @param {Command} command - Command found by the dispatcher
  * @returns {boolean}
  */
	hasRoles(dm, message, command) {
		return this._bot.selfbot || command.roles.length === 0 || dm || message.member.roles.filter(role => command.roles.includes(role.name)).size > 0;
	}

	/**
  * Send a 'command not found' error message to the channel
  * @memberof CommandDispatcher
  * @instance
  * @param {external:Message} message - Discord.js message object
  * @returns {Promise<external:Message>}
  */
	commandNotFoundError(message) {
		return message.channel.sendMessage(`` + `Sorry, I didn't recognize any command in your message.\n` + `Try saying "help" to view a list of commands you can use in ` + `this DM, or try calling the\nhelp command in a server channel ` + `to see what commands you can use there!`);
	}

	/**
  * Send a 'guild only' error message to the channel
  * @memberof CommandDispatcher
  * @instance
  * @param {external:Message} message - Discord.js message object
  * @returns {Promise<external:Message>}
  */
	guildOnlyError(message) {
		return message.channel.sendMessage(`` + `That command is for servers only. Try saying "help" to see a ` + `list of commands you can use in this DM`);
	}

	/**
  * Send a 'missing permissions' error message to the channel
  * @memberof CommandDispatcher
  * @instance
  * @param {external:PermissionResolvable[]} missing - Array of missing permissions
  * @param {external:Message} message - Discord.js message object
  * @returns {Promise<external:Message>}
  */
	missingPermissionsError(missing, message) {
		return message[`${ this._bot.selfbot ? 'channel' : 'author' }`].sendMessage(`` + `**You're missing the following permission` + `${ missing.length > 1 ? 's' : '' } ` + `for that command:**\n\`\`\`css\n` + `${ missing.join(', ') }\n\`\`\``).then(response => {
			if (this._bot.selfbot) response.delete(10e3);
		});
	}

	/**
  * Send a 'missing roles' error message to the channel
  * @memberof CommandDispatcher
  * @instance
  * @param {external:Message} message - Discord.js message object
  * @param {Command} command - Command found by the dispatcher
  * @returns {Promise<external:Message>}
  */
	missingRolesError(message, command) {
		return message[`${ this._bot.selfbot ? 'channel' : 'author' }`].sendMessage(`` + `**You must have ${ command.roles.length > 1 ? 'one of the following roles' : 'the following role' }` + ` to use that command:**\n\`\`\`css\n` + `${ command.roles.join(', ') }\n\`\`\``).then(response => {
			if (this._bot.selfbot) response.delete(10e3);
		});
	}

	/**
  * Send a 'missing roles for role-limited command' error
  * message to the channel
  * @memberof CommandDispatcher
  * @instance
  * @param {external:Message} message - Discord.js message object
  * @param {Command} command - Command found by the dispatcher
  * @returns {Promise<external:Message>}
  */
	failedLimiterError(message, command) {
		const storage = this._bot.guildStorages.get(message.guild);
		let limitedCommands = storage.getSetting('limitedCommands');
		let roles = limitedCommands[command.name];
		return message[`${ this._bot.selfbot ? 'channel' : 'author' }`].send(`` + `**You must have ${ roles.length > 1 ? 'one of the following roles' : 'the following role' }` + ` to use that command:**\n\`\`\`css\n` + `${ message.guild.roles.filter(role => roles.includes(role.id)).map(role => role.name).join(', ') }\n\`\`\``);
	}

	/**
  * Pass the necessary items to the found Command's {@link Command#action} method
  * @memberof CommandDispatcher
  * @instance
  * @param {Command} command - The command found by the dispatcher
  * @param {external:Message} message - Discord.js message object
  * @param {args[]} args - An array containing the args parsed from the command calling message
  * @param {external:User[]} mentions - An array containing the Discord.js User
  * objects parsed from the mentions contained in a message
  * @param {string} original - The original raw content of the message that called the command
  * @returns {Promise<*>}
  */
	dispatch(command, message, args, mentions, original) {
		return new Promise(function ($return, $error) {
			return $return(new Promise((resolve, reject) => {
				try {
					const action = command.action(message, args, mentions, original);
					if (action instanceof Promise) action.then(resolve).catch(reject);else resolve(action);
				} catch (err) {
					reject(err);
				}
			}));
		}.$asyncbind(this));
	}
}
exports.default = CommandDispatcher;