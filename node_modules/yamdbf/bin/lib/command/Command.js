'use babel';
'use strict';

/**
 * Command class to extend to create commands users can execute
 * @class Command
 * @param {Bot} bot - Bot instance
 * @param {CommandInfo} info - Object containing required command properties
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

Function.prototype.$asyncbind = function $asyncbind(self, catcher) {
	"use strict";

	if (!Function.prototype.$asyncbind) {
		Object.defineProperty(Function.prototype, "$asyncbind", {
			value: $asyncbind,
			enumerable: false,
			configurable: true,
			writable: true
		});
	}

	if (!$asyncbind.trampoline) {
		$asyncbind.trampoline = function trampoline(t, x, s, e, u) {
			return function b(q) {
				while (q) {
					if (q.then) {
						q = q.then(b, e);
						return u ? undefined : q;
					}

					try {
						if (q.pop) {
							if (q.length) return q.pop() ? x.call(t) : q;
							q = s;
						} else q = q.call(t);
					} catch (r) {
						return e(r);
					}
				}
			};
		};
	}

	if (!$asyncbind.LazyThenable) {
		$asyncbind.LazyThenable = function () {
			function isThenable(obj) {
				return obj && obj instanceof Object && typeof obj.then === "function";
			}

			function resolution(p, r, how) {
				try {
					var x = how ? how(r) : r;
					if (p === x) return p.reject(new TypeError("Promise resolution loop"));

					if (isThenable(x)) {
						x.then(function (y) {
							resolution(p, y);
						}, function (e) {
							p.reject(e);
						});
					} else {
						p.resolve(x);
					}
				} catch (ex) {
					p.reject(ex);
				}
			}

			function Chained() {}

			;
			Chained.prototype = {
				resolve: _unchained,
				reject: _unchained,
				then: thenChain
			};

			function _unchained(v) {}

			function thenChain(res, rej) {
				this.resolve = res;
				this.reject = rej;
			}

			function then(res, rej) {
				var chain = new Chained();

				try {
					this._resolver(function (value) {
						return isThenable(value) ? value.then(res, rej) : resolution(chain, value, res);
					}, function (ex) {
						resolution(chain, ex, rej);
					});
				} catch (ex) {
					resolution(chain, ex, rej);
				}

				return chain;
			}

			function Thenable(resolver) {
				this._resolver = resolver;
				this.then = then;
			}

			;

			Thenable.resolve = function (v) {
				return Thenable.isThenable(v) ? v : {
					then: function then(resolve) {
						return resolve(v);
					}
				};
			};

			Thenable.isThenable = isThenable;
			return Thenable;
		}();

		$asyncbind.EagerThenable = $asyncbind.Thenable = ($asyncbind.EagerThenableFactory = function (tick) {
			tick = tick || typeof process === "object" && process.nextTick || typeof setImmediate === "function" && setImmediate || function (f) {
				setTimeout(f, 0);
			};

			var soon = function () {
				var fq = [],
				    fqStart = 0,
				    bufferSize = 1024;

				function callQueue() {
					while (fq.length - fqStart) {
						fq[fqStart]();
						fq[fqStart++] = undefined;

						if (fqStart === bufferSize) {
							fq.splice(0, bufferSize);
							fqStart = 0;
						}
					}
				}

				return function (fn) {
					fq.push(fn);
					if (fq.length - fqStart === 1) tick(callQueue);
				};
			}();

			function Zousan(func) {
				if (func) {
					var me = this;
					func(function (arg) {
						me.resolve(arg);
					}, function (arg) {
						me.reject(arg);
					});
				}
			}

			Zousan.prototype = {
				resolve: function resolve(value) {
					if (this.state !== undefined) return;
					if (value === this) return this.reject(new TypeError("Attempt to resolve promise with self"));
					var me = this;

					if (value && (typeof value === "function" || typeof value === "object")) {
						try {
							var first = 0;
							var then = value.then;

							if (typeof then === "function") {
								then.call(value, function (ra) {
									if (!first++) {
										me.resolve(ra);
									}
								}, function (rr) {
									if (!first++) {
										me.reject(rr);
									}
								});
								return;
							}
						} catch (e) {
							if (!first) this.reject(e);
							return;
						}
					}

					this.state = STATE_FULFILLED;
					this.v = value;
					if (me.c) soon(function () {
						for (var n = 0, l = me.c.length; n < l; n++) STATE_FULFILLED(me.c[n], value);
					});
				},
				reject: function reject(reason) {
					if (this.state !== undefined) return;
					this.state = STATE_REJECTED;
					this.v = reason;
					var clients = this.c;
					if (clients) soon(function () {
						for (var n = 0, l = clients.length; n < l; n++) STATE_REJECTED(clients[n], reason);
					});
				},
				then: function then(onF, onR) {
					var p = new Zousan();
					var client = {
						y: onF,
						n: onR,
						p: p
					};

					if (this.state === undefined) {
						if (this.c) this.c.push(client);else this.c = [client];
					} else {
						var s = this.state,
						    a = this.v;
						soon(function () {
							s(client, a);
						});
					}

					return p;
				}
			};

			function STATE_FULFILLED(c, arg) {
				if (typeof c.y === "function") {
					try {
						var yret = c.y.call(undefined, arg);
						c.p.resolve(yret);
					} catch (err) {
						c.p.reject(err);
					}
				} else c.p.resolve(arg);
			}

			function STATE_REJECTED(c, reason) {
				if (typeof c.n === "function") {
					try {
						var yret = c.n.call(undefined, reason);
						c.p.resolve(yret);
					} catch (err) {
						c.p.reject(err);
					}
				} else c.p.reject(reason);
			}

			Zousan.resolve = function (val) {
				if (val && val instanceof Zousan) return val;
				var z = new Zousan();
				z.resolve(val);
				return z;
			};

			Zousan.reject = function (err) {
				if (err && err instanceof Zousan) return err;
				var z = new Zousan();
				z.reject(err);
				return z;
			};

			Zousan.version = "2.3.2-nodent";
			return Zousan;
		})();
	}

	var resolver = this;

	switch (catcher) {
		case true:
			return new $asyncbind.Thenable(boundThen);

		case 0:
			return new $asyncbind.LazyThenable(boundThen);

		case undefined:
			boundThen.then = boundThen;
			return boundThen;

		default:
			return function () {
				try {
					return resolver.apply(self, arguments);
				} catch (ex) {
					return catcher(ex);
				}
			};
	}

	function boundThen() {
		return resolver.apply(self, arguments);
	}
};

class Command {
	constructor(bot, info = null) // eslint-disable-line complexity
	{
		// Assert necessary command information
		const name = this.constructor.name;
		if (!info) throw new Error(`You must provide an info object for command: ${ name }`);
		if (!info.name) throw new Error(`You must provide a name for command: ${ name }`);
		if (!info.description) throw new Error(`You must provide a description for command: ${ name }`);
		if (!info.usage) throw new Error(`You must provide usage information for command: ${ name }`);
		if (!info.group) throw new Error(`You must provide a group for command: ${ name }`);
		if (info.aliases && !Array.isArray(info.aliases)) throw new Error(`Aliases for command ${ name } must be an array`);
		if (info.permissions && !Array.isArray(info.permissions)) throw new Error(`Permissions for command ${ name } must be an array`);
		if (info.permissions && info.permissions.length > 0) info.permissions.forEach((perm, index) => {
			try {
				bot.resolver.resolvePermission(perm);
			} catch (err) {
				throw new Error(`Command#${ name } permission "${ info.permissions[index] }" at ${ name }.permissions[${ index }] is not a valid permission.\n\n${ err }`);
			}
		});
		if (info.roles && !Array.isArray(info.roles)) throw new Error(`Roles for command ${ name } must be an array`);

		/**
   * Bot instance
   * @memberof Command
   * @type {Bot}
   * @name bot
   * @instance
   */
		this.bot = bot;

		/**
   * The name of the command, used by the dispatcher
   * to determine the command being executed
   * @memberof Command
   * @type {string}
   * @name name
   * @instance
   */
		this.name = info.name;

		/**
   * A brief description of the command, displayed
   * in the commands list via the Help command
   * @memberof Command
   * @type {string}
   * @name description
   * @instance
   */
		this.description = info.description;

		/**
   * An example of command usage. The token '&lt;prefix&gt;' will
   * be replaced by the guild-specific command prefix in the Help command when
   * 'help &lt;command&gt;' is called
   * @memberof Command
   * @type {string}
   * @name usage
   * @instance
   */
		this.usage = info.usage;

		/**
   * Extra information about the command to be displayed
   * by the Help command when 'help &lt;command&gt;' is called
   * @memberof Command
   * @type {string}
   * @name extraHelp
   * @instance
   */
		this.extraHelp = info.extraHelp;

		/**
   * The command group that the command belongs to. Allows commands to be
   * grouped for disabling. The group 'base' cannot be disabled.
   * @memberof Command
   * @type {string}
   * @name group
   * @instance
   */
		this.group = info.group;

		/**
   * Aliases the command can be called by other than its name
   * @memberof Command
   * @type {string[]}
   * @name aliases
   * @instance
   */
		this.aliases = info.aliases || [];

		/**
   * Whether or not a command can only be used within a
   * guild text channel
   * @memberof Command
   * @type {boolean}
   * @name guildOnly
   * @instance
   */
		this.guildOnly = info.guildOnly || false;

		/**
   * Whether or not the command is to be hidden from the
   * commands list via the default help command
   */
		this.hidden = info.hidden || false;

		/**
   * Options for how arguments should be parsed. See: {@link ArgOpts}
   * @memberof Command
   * @type {ArgOpts}
   * @name argOpts
   * @instance
   */
		this.argOpts = info.argOpts || {};
		this.argOpts.stringArgs = this.argOpts.stringArgs || false;
		this.argOpts.separator = this.argOpts.separator || ' ';

		/**
   * Array of permissions required by the command
   * caller to be able to execute the command in the guild the command is called in.
   * <br><br>
   * If any permissions are provided the command's `guildOnly` property will be automatically set to true
   * @memberof Command
   * @type {external:PermissionResolvable[]}
   * @name permissions
   * @instance
   */
		this.permissions = info.permissions || [];

		/**
   * Array of roles required to use the command. If the command caller
   * has any of the roles in the array, they will be able to use the command
   * <br><br>
   * If any roles are provided the command's `guildOnly` property will be automatically set to true
   * @memberof Command
   * @type {string[]}
   * @name roles
   * @instance
   */
		this.roles = info.roles || [];

		/**
   * Whether or not the command can be used by the bot owner(s).
   * @memberof Command
   * @type {boolean}
   * @name ownerOnly
   * @instance
   * @see [Bot#config.owner]{@link Bot#config}
   */
		this.ownerOnly = info.ownerOnly || false;

		/**
   * The name of a base command to overload. Commands may only overload
   * base commands so the {@link Command#group} must be set to 'base' in
   * order to overload. Commands may only be overloaded by name, not by alias
   * @memberof Command
   * @type {string}
   * @name overloads
   * @instance
   */
		this.overloads = info.overloads || null;

		if (this.overloads && this.group !== 'base') throw new Error('Commands may only overload commands in group "base"');

		// Default guildOnly to true if permissions/roles are given
		if (this.permissions.length > 0 || this.roles.length > 0) this.guildOnly = true;
	}

	/**
  * @typedef {Array<string|number>} args - Array of values parsed from {@link external:Message} content
  * that will be passed to a command. Can contain a mix of string and number values.
  */

	/**
  * Action to be executed when the command is called. The following parameters
  * are what command actions will be passed by the {@link CommandDispatcher} whenever
  * a command is called. Be sure to receive these in proper order when writing
  * new commands
  * @memberof Command
  * @instance
  * @param {external:Message} message - Discord.js message object
  * @param {args[]} args - An array containing the args parsed from the command calling message
  * @param {external:User[]} mentions - An array containing the Discord.js User
  * objects parsed from the mentions contained in a message
  * @param {string} original - The original raw content of the message that called the command
  */
	action() {
		return new Promise(function ($return, $error) {
			return $error(new Error(`${ this.constructor.name } has not overloaded the command action method`));
		}.$asyncbind(this));
	}

	/**
  * Assert {@link Command#action} is typeof Function, finishing the
  * command creation process.<br>Called by {@link CommandRegistry#register}
  * @memberof Command
  * @instance
  */
	register() {
		let name = this.constructor.name;
		if (!this.action) throw new Error(`Command#${ name }.action: expected Function, got: ${ typeof this.action }`);
		if (!(this.action instanceof Function)) throw new Error(`Command#${ name }.action: expected Function, got: ${ typeof this.action }`);
	}

	// Send provided response text to the command's calling channel
	// via edit, editCode, sendMessage, or sendCode depending on Whether
	// or not the bot is a selfbot and/or a codeblock language is given
	_respond(message, response, code) {
		if (this.bot.selfbot && !code) return message.edit(response);
		if (this.bot.selfbot && code) return message.editCode(code, response);
		if (code) return message.channel.sendCode(code, response);
		return message.channel.sendMessage(response);
	}
}

exports.default = Command; /**
                            * @typedef {Object} CommandInfo - Object containing required {@link Command} properties
                            * to be passed to a Command on construction
                            * @property {string} name - See: {@link Command#name}
                            * @property {string} description - See: {@link Command#description}
                            * @property {string} usage - See: {@link Command#usage}
                            * @property {string} extraHelp - See: {@link Command#extraHelp}
                            * @property {string} group - See: {@link Command#group}
                            * @property {string[]} [aliases=[]] - See: {@link Command#aliases}
                            * @property {boolean} [guildOnly=false] - See: {@link Command#guildOnly}
                            * @property {boolean} [hidden=false] - See: {@link Command#hidden}
                            * @property {ArgOpts} [argOpts] - See: {@link Command#argOpts}, {@link ArgOpts}
                            * @property {PermissionResolvable[]} [permissions=[]] - See: {@link Command#permissions}
                            * @property {string[]} [roles=[]] - See: {@link Command#roles}
                            * @property {boolean} [ownerOnly=false] - See: {@link Command#ownerOnly}
                            * @property {string} [overloads=null] - See: {@link Command#overloads}
                            */

/**
 * @typedef {Object} ArgOpts - Object containing options for
 * controlling how command arguments will be parsed
 * @property {boolean} stringArgs - Whether or not to parse all args as strings
 * @property {string} [separator=' '] - The charactor to separate args by
 */