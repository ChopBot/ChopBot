'use babel';
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _discord = require('discord.js');

Function.prototype.$asyncbind = function anonymous(self, catcher) {
	var resolver = this;

	if (catcher === true) {
		if (!Function.prototype.$asyncbind.EagerThenable) Function.prototype.$asyncbind.EagerThenable = function factory(tick) {
			var _tasks = [];

			if (!tick) {
				try {
					tick = process.nextTick;
				} catch (ex) {
					tick = function tick(p) {
						setTimeout(p, 0);
					};
				}
			}

			function _untask() {
				for (var i = 0; i < _tasks.length; i += 2) {
					var t = _tasks[i + 1],
					    r = _tasks[i];

					for (var j = 0; j < t.length; j++) t[j].call(null, r);
				}

				_tasks = [];
			}

			function isThenable(obj) {
				return obj && obj instanceof Object && typeof obj.then === 'function';
			}

			function EagerThenable(resolver) {
				function done(inline) {
					var w;
					if (_sync || phase < 0 || (w = _thens[phase]).length === 0) return;

					_tasks.push(result, w);

					_thens = [[], []];
					if (_tasks.length === 2) inline ? _untask() : tick(_untask);
				}

				function resolveThen(x) {
					if (phase >= 0) return;
					if (isThenable(x)) return x.then(resolveThen, rejectThen);
					phase = 0;
					result = x;
					done(true);
				}

				function rejectThen(x) {
					if (phase >= 0) return;
					if (isThenable(x)) return x.then(resolveThen, rejectThen);
					phase = 1;
					result = x;
					done(true);
				}

				function settler(resolver, rejecter) {
					_thens[0].push(resolver);

					_thens[1].push(rejecter);

					done();
				}

				function toString() {
					return 'EagerThenable{' + {
						'-1': 'pending',
						0: 'resolved',
						1: 'rejected'
					}[phase] + '}=' + result.toString();
				}

				function guard() {
					try {
						resolver.call(null, resolveThen, rejectThen);
					} catch (ex) {
						rejectThen(ex);
					}
				}

				this.then = settler;
				this.toString = toString;
				var _thens = [[], []],
				    _sync = true,
				    phase = -1,
				    result;
				guard();
				_sync = false;
				done();
			}

			EagerThenable.resolve = function (v) {
				return isThenable(v) ? v : {
					then: function then(resolve, reject) {
						return resolve(v);
					}
				};
			};

			return EagerThenable;
		}();
		return new Function.prototype.$asyncbind.EagerThenable(boundThen);
	}

	if (catcher) {
		if (Function.prototype.$asyncbind.wrapAsyncStack) catcher = Function.prototype.$asyncbind.wrapAsyncStack(catcher);
		return then;
	}

	function then(result, error) {
		try {
			return result && result instanceof Object && typeof result.then === 'function' ? result.then(then, catcher) : resolver.call(self, result, error || catcher);
		} catch (ex) {
			return (error || catcher)(ex);
		}
	}

	function boundThen(result, error) {
		return resolver.call(self, result, error);
	}

	boundThen.then = boundThen;
	return boundThen;
};

/**
 * Stores loaded Commands as &lt;[name]{@link Command#name}, [Command]{@link Command}&gt; pairs
 * @class CommandRegistry
 * @extends {external:Collection}
 */
class CommandRegistry extends _discord.Collection {
	constructor() {
		super();
	}

	/**
  * Complete registration of a command and add to the parent [Collection]{@link external:Collection},
  * erroring on duplicate names and aliases
  * @memberof CommandRegistry
  * @instance
  * @param {Command} command - The Command to be registered
  * @param {string} key - The key to store the Command at. Will be {@link Command#name}
  * @param {boolean} reload - Whether or not the command is being reloaded and
  * replaced in the collection
  */
	register(command, key, reload) {
		if (super.has(command.name) && !reload && !(command.overloads && command.overloads !== super.get(command.overload).name)) throw new Error(`A command with the name "${ command.name }" already exists.`);

		this.forEach(a => {
			a.aliases.forEach(b => {
				let duplicates = this.filter(c => c.aliases.includes(b) && c !== a);
				if (duplicates.size > 0) throw new Error(`Commands may not share aliases: ${ duplicates.first().name }, ${ a.name } (shared alias: ${ b })`);
			});
		});

		command.register();
		super.set(key, command);
	}

	/**
  * Contains all [Command groups]{@link Command#group}
  * @memberof CommandRegistry
  * @instance
  * @type {string[]}
  */
	get groups() {
		return this.map(a => a.group).filter((a, i, self) => self.indexOf(a) === i);
	}

	/**
  * Finds a command by [name]{@link Command#name} or [alias]{@link Command#aliases}
  * @memberof CommandRegistry
  * @instance
  * @param {string} text - The name or alias of the Command
  * @returns {Command}
  */
	findByNameOrAlias(text) {
		return this.filter(c => c.name === text || c.aliases.includes(text)).first();
	}

	/**
  * Returns all commands usable by the user in the guild text channel
  * the provided message is in
  * @memberof CommandRegistry
  * @instance
  * @param {Bot} bot - Bot instance
  * @param {external:Message} message - Discord.js Message object
  * @returns {external:Collection<string, Command>}
  */
	filterGuildUsable(bot, message) {
		return this.filter(c => c.permissions.length > 0 ? c.permissions.filter(a => message.channel.permissionsFor(message.author).hasPermission(a)).length > 0 : true).filter(c => !(c.roles.length > 0 && !message.member.roles.filter(role => c.roles.includes(role.name)).size > 0)).filter(c => !bot.guildStorages.get(message.guild).settingExists('disabledGroups') || !bot.guildStorages.get(message.guild).getSetting('disabledGroups').includes(c.group)).filter(c => bot.config.owner.includes(message.author.id) && c.ownerOnly || !c.ownerOnly);
	}

	/**
  * Returns all commands usable by the user within the DM channel the provided
  * message is in
  * @memberof CommandRegistry
  * @instance
  * @param {Bot} bot - Bot instance
  * @param {external:Message} message - Discord.js Message object
  * @returns {external:Collection<string, Command>}
  */
	filterDMUsable(bot, message) {
		return this.filter(c => !c.guildOnly && (bot.config.owner.includes(message.author.id) && c.ownerOnly || !c.ownerOnly));
	}

	// Returns all commands that can have their help looked up in
	// a DM by the user
	/**
  * Returns all commands that can have their help looked up by the user
  * in the DM channel the message is in
  * @memberof CommandRegistry
  * @instance
  * @param {Bot} bot - Bot instance
  * @param {external:Message} message - Discord.js Message object
  * @returns {external:Collection<string, Command>}
  */
	filterDMHelp(bot, message) {
		return this.filter(c => bot.config.owner.includes(message.author.id) && c.ownerOnly || !c.ownerOnly);
	}
}
exports.default = CommandRegistry;