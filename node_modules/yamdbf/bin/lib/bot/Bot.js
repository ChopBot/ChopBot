'use babel';
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _discord = require('discord.js');

var _LocalStorage = require('../storage/LocalStorage');

var _LocalStorage2 = _interopRequireDefault(_LocalStorage);

var _GuildStorageLoader = require('../storage/GuildStorageLoader');

var _GuildStorageLoader2 = _interopRequireDefault(_GuildStorageLoader);

var _GuildStorageRegistry = require('../storage/GuildStorageRegistry');

var _GuildStorageRegistry2 = _interopRequireDefault(_GuildStorageRegistry);

var _CommandLoader = require('../command/CommandLoader');

var _CommandLoader2 = _interopRequireDefault(_CommandLoader);

var _CommandRegistry = require('../command/CommandRegistry');

var _CommandRegistry2 = _interopRequireDefault(_CommandRegistry);

var _CommandDispatcher = require('../command/CommandDispatcher');

var _CommandDispatcher2 = _interopRequireDefault(_CommandDispatcher);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Function.prototype.$asyncbind = function anonymous(self, catcher) {
	var resolver = this;

	if (catcher === true) {
		if (!Function.prototype.$asyncbind.EagerThenable) Function.prototype.$asyncbind.EagerThenable = function factory(tick) {
			var _tasks = [];

			if (!tick) {
				try {
					tick = process.nextTick;
				} catch (ex) {
					tick = function tick(p) {
						setTimeout(p, 0);
					};
				}
			}

			function _untask() {
				for (var i = 0; i < _tasks.length; i += 2) {
					var t = _tasks[i + 1],
					    r = _tasks[i];

					for (var j = 0; j < t.length; j++) t[j].call(null, r);
				}

				_tasks = [];
			}

			function isThenable(obj) {
				return obj && obj instanceof Object && typeof obj.then === 'function';
			}

			function EagerThenable(resolver) {
				function done(inline) {
					var w;
					if (_sync || phase < 0 || (w = _thens[phase]).length === 0) return;

					_tasks.push(result, w);

					_thens = [[], []];
					if (_tasks.length === 2) inline ? _untask() : tick(_untask);
				}

				function resolveThen(x) {
					if (phase >= 0) return;
					if (isThenable(x)) return x.then(resolveThen, rejectThen);
					phase = 0;
					result = x;
					done(true);
				}

				function rejectThen(x) {
					if (phase >= 0) return;
					if (isThenable(x)) return x.then(resolveThen, rejectThen);
					phase = 1;
					result = x;
					done(true);
				}

				function settler(resolver, rejecter) {
					_thens[0].push(resolver);

					_thens[1].push(rejecter);

					done();
				}

				function toString() {
					return 'EagerThenable{' + {
						'-1': 'pending',
						0: 'resolved',
						1: 'rejected'
					}[phase] + '}=' + result.toString();
				}

				function guard() {
					try {
						resolver.call(null, resolveThen, rejectThen);
					} catch (ex) {
						rejectThen(ex);
					}
				}

				this.then = settler;
				this.toString = toString;
				var _thens = [[], []],
				    _sync = true,
				    phase = -1,
				    result;
				guard();
				_sync = false;
				done();
			}

			EagerThenable.resolve = function (v) {
				return isThenable(v) ? v : {
					then: function then(resolve, reject) {
						return resolve(v);
					}
				};
			};

			return EagerThenable;
		}();
		return new Function.prototype.$asyncbind.EagerThenable(boundThen);
	}

	if (catcher) {
		if (Function.prototype.$asyncbind.wrapAsyncStack) catcher = Function.prototype.$asyncbind.wrapAsyncStack(catcher);
		return then;
	}

	function then(result, error) {
		try {
			return result && result instanceof Object && typeof result.then === 'function' ? result.then(then, catcher) : resolver.call(self, result, error || catcher);
		} catch (ex) {
			return (error || catcher)(ex);
		}
	}

	function boundThen(result, error) {
		return resolver.call(self, result, error);
	}

	boundThen.then = boundThen;
	return boundThen;
};

/**
 * The Discord.js Client instance. Contains bot-specific [storage]{@link Bot#storage},
 * guild specific [storages]{@link Bot#guildStorages}, and contains important
 * fields for access within commands
 * @class Bot
 * @extends {external:Client}
 * @param {BotOptions} botOptions - Object containing required bot properties
 * @param {external:ClientOptions} [clientOptions] - Discord.js ClientOptions
 */
class Bot extends _discord.Client {
	constructor(botOptions = null, clientOptions) {
		super(clientOptions);

		/** @type {string} */
		this._token = botOptions.token;

		/**
   * The name of the Bot
   * @memberof Bot
   * @type {string}
   * @name name
   * @instance
   */
		this.name = botOptions.name || 'botname';

		/**
   * Directory to find command class files. Optional
   * if bot is passive. See: {@link Bot#passive}
   * @memberof Bot
   * @type {string}
   * @name commandsDir
   * @instance
   */
		this.commandsDir = botOptions.commandsDir || null;

		/**
   * Status text for the bot
   * @memberof Bot
   * @type {?string}
   * @name statusText
   * @instance
   */
		this.statusText = botOptions.statusText || null;

		/**
   * Text to output when the bot is ready
   * @memberof Bot
   * @type {string}
   * @name readyText
   * @instance
   */
		this.readyText = botOptions.readyText || 'Ready!';

		/**
   * Whether or not the bot is a selfbot
   * @memberof Bot
   * @type {boolean}
   * @name selfbot
   * @instance
   */
		this.selfbot = botOptions.selfbot || false;

		/**
   * Whether or not this bot is passive. Passive bots
   * will not register a command dispatcher or a message
   * listener. This allows passive bots to be created that
   * do not respond to any commands but are able to perform
   * actions based on whatever the framework user wants
   * @memberof Bot
   * @type {boolean}
   * @name passive
   * @instance
   */
		this.passive = botOptions.passive || false;

		/**
   * Bot version, best taken from package.json
   * @memberof Bot
   * @type {string}
   * @name version
   * @instance
   */
		this.version = botOptions.version || '0.0.0';

		/**
   * Object containing token and owner ids
   * @memberof Bot
   * @type {Object}
   * @name config
   * @instance
   * @property {string} token - Discord login token for the bot
   * @property {string[]} owner - Array of owner id strings
   */
		this.config = botOptions.config || null;

		/**
   * Array of base command names to skip when loading commands. Base commands
   * may only be disabled by name, not by alias
   * @memberof Bot
   * @type {string[]}
   * @name disableBase
   * @instance
   */
		this.disableBase = botOptions.disableBase || [];

		/** @type {LocalStorage} */
		this._guildDataStorage = new _LocalStorage2.default('storage/guild-storage');

		/** @type {LocalStorage} */
		this._guildSettingStorage = new _LocalStorage2.default('storage/guild-settings');

		/** @type {GuildStorageLoader} */
		this._guildStorageLoader = new _GuildStorageLoader2.default(this);

		/** @type {CommandLoader} */
		this._commandLoader = new _CommandLoader2.default(this);

		/**
   * Bot-specific storage
   * @memberof Bot
   * @type {LocalStorage}
   * @name storage
   * @instance
   */
		this.storage = new _LocalStorage2.default('storage/bot-storage');

		/**
   * [Collection]{@link external:Collection} containing all GuildStorage instances
   * @memberof Bot
   * @type {GuildStorageRegistry<string, GuildStorage>}
   * @name guildStorages
   * @instance
   */
		this.guildStorages = new _GuildStorageRegistry2.default();

		/**
   * [Collection]{@link external:Collection} containing all loaded commands
   * @memberof Bot
   * @type {CommandRegistry<string, Command>}
   * @name commands
   * @instance
   */
		this.commands = new _CommandRegistry2.default();

		/**
   * @typedef {Object} DefaultGuildSettings - The default settings to apply to new guilds.
   * Stored under the key <code>'defaultGuildSettings'</code> in {@link Bot#storage}
   * @property {string} prefix='/' - Prefix to prepend commands
   * @property {Array} [disabledGroups=[]] - Command groups to ignore
   */

		// Load defaultGuildSettings into storage the first time the bot is run
		if (!this.storage.exists('defaultGuildSettings')) // eslint-disable-line curly
			this.storage.setItem('defaultGuildSettings', require('../storage/defaultGuildSettings.json'));

		/** @type {CommandDispatcher} */
		this._dispatcher = new _CommandDispatcher2.default(this);

		// Make some asserts
		if (!this._token) throw new Error('You must provide a token for the bot.');
		if (!this.commandsDir && !this.passive) throw new Error('You must provide a directory to load commands from via commandDir');
		if (!this.config) throw new Error('You must provide a config containing token and owner ids.');

		// Load commands
		if (!this.passive) this.loadCommand('all');
	}

	/**
  * Loads/reloads all/specific commands
  * @memberof Bot
  * @instance
  * @param {string} command - The name of a command to reload, or 'all' to load all commands
  */
	loadCommand(command) {
		if (!command) throw new Error(`You must provide a command name to load, or 'all' to load all commands`);
		if (command === 'all') this._commandLoader.loadCommands();else this._commandLoader.reloadCommand(command);
	}

	/**
  * Logs the Bot in and registers some event handlers
  * @memberof Bot
  * @instance
  * @returns {Bot}
  */
	start() {
		this.login(this._token);

		this.once('ready', () => {
			console.log(this.readyText); // eslint-disable-line no-console
			this.user.setGame(this.statusText);

			// Load all guild storages
			this._guildStorageLoader.loadStorages(this._guildDataStorage, this._guildSettingStorage);
		});

		this.on('guildCreate', () => {
			this._guildStorageLoader.initNewGuilds(this._guildDataStorage, this._guildSettingStorage);
		});

		this.on('guildDelete', guild => {
			this.guildStorages.delete(guild.id);
			this._guildDataStorage.removeItem(guild.id);
			this._guildSettingStorage.removeItem(guild.id);
		});

		return this;
	}

	/**
  * Set the value of a default setting key and push it to all guild
  * setting storages. Will not overwrite a setting in guild settings
  * storage if there is already an existing key with the given value
  * @memberof Bot
  * @instance
  * @param {string} key - The key to use in settings storage
  * @param {string} value - The value to use in settings storage
  * @returns {Bot}
  */
	setDefaultSetting(key, value) {
		this.storage.setItem(`defaultGuildSettings/${ key }`, value);
		this.guildStorages.forEach(guild => {
			if (!guild.settingExists(key)) guild.setSetting(key, value);
		});
		return this;
	}

	/**
  * Remove a defaultGuildSettings item. Will not remove from ALL guild
  * settings, but will prevent the item from being added to new guild
  * settings storage upon creation
  * @memberof Bot
  * @instance
  * @param {string} key - The key to use in settings storage
  * @returns {Bot}
  */
	removeDefaultSetting(key) {
		this.storage.removeItem(`defaultGuildSettings/${ key }`);
		return this;
	}

	/**
  * See if a guild default setting exists
  * @memberof Bot
  * @instance
  * @param {string} key - The key in storage to check
  * @returns {boolean}
  */
	defaultSettingExists(key) {
		return !!this.storage.getItem('defaultGuildSettings')[key];
	}

	/**
  * Shortcut to return the command prefix for the provided guild
  * @memberof Bot
  * @instance
  * @param {(external:Guild|string)} guild - The guild or guild id to get the prefix of
  * @returns {string|null}
  */
	getPrefix(guild) {
		if (!guild) return null;
		return this.guildStorages.get(guild).getSetting('prefix') || null;
	}
}

exports.default = Bot; /**
                        * @typedef {Object} BotOptions Object containing required {@link Bot} properties to be
                        * passed to a Bot on construction
                        * @property {string} [name='botname'] - See: {@link Bot#name}
                        * @property {string} token - See: {@link Bot#token}
                        * @property {string} [commandsDir] - See: {@link Bot#commandsDir}
                        * @property {string} [statusText=null] - See: {@link Bot#statusText}
                        * @property {string} [readyText='Ready!'] - See: {@link Bot#readyText}
                        * @property {boolean} [selfbot=false] - See: {@link Bot#selfbot}
                        * @property {boolean} [passive=false] - see {@link Bot#passive}
                        * @property {string} [version='0.0.0'] - See: {@link Bot#version}
                        * @property {Object} config - See: {@link Bot#config}
                        * @property {string[]} [disableBase=[]] - See: {@link Bot#disableBase}
                        */