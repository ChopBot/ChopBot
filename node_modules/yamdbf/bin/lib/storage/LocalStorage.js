'use babel';
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _nodeJsonDb = require('node-json-db');

var _nodeJsonDb2 = _interopRequireDefault(_nodeJsonDb);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Function.prototype.$asyncbind = function anonymous(self, catcher) {
	var resolver = this;

	if (catcher === true) {
		if (!Function.prototype.$asyncbind.EagerThenable) Function.prototype.$asyncbind.EagerThenable = function factory(tick) {
			var _tasks = [];

			if (!tick) {
				try {
					tick = process.nextTick;
				} catch (ex) {
					tick = function tick(p) {
						setTimeout(p, 0);
					};
				}
			}

			function _untask() {
				for (var i = 0; i < _tasks.length; i += 2) {
					var t = _tasks[i + 1],
					    r = _tasks[i];

					for (var j = 0; j < t.length; j++) t[j].call(null, r);
				}

				_tasks = [];
			}

			function isThenable(obj) {
				return obj && obj instanceof Object && typeof obj.then === 'function';
			}

			function EagerThenable(resolver) {
				function done(inline) {
					var w;
					if (_sync || phase < 0 || (w = _thens[phase]).length === 0) return;

					_tasks.push(result, w);

					_thens = [[], []];
					if (_tasks.length === 2) inline ? _untask() : tick(_untask);
				}

				function resolveThen(x) {
					if (phase >= 0) return;
					if (isThenable(x)) return x.then(resolveThen, rejectThen);
					phase = 0;
					result = x;
					done(true);
				}

				function rejectThen(x) {
					if (phase >= 0) return;
					if (isThenable(x)) return x.then(resolveThen, rejectThen);
					phase = 1;
					result = x;
					done(true);
				}

				function settler(resolver, rejecter) {
					_thens[0].push(resolver);

					_thens[1].push(rejecter);

					done();
				}

				function toString() {
					return 'EagerThenable{' + {
						'-1': 'pending',
						0: 'resolved',
						1: 'rejected'
					}[phase] + '}=' + result.toString();
				}

				function guard() {
					try {
						resolver.call(null, resolveThen, rejectThen);
					} catch (ex) {
						rejectThen(ex);
					}
				}

				this.then = settler;
				this.toString = toString;
				var _thens = [[], []],
				    _sync = true,
				    phase = -1,
				    result;
				guard();
				_sync = false;
				done();
			}

			EagerThenable.resolve = function (v) {
				return isThenable(v) ? v : {
					then: function then(resolve, reject) {
						return resolve(v);
					}
				};
			};

			return EagerThenable;
		}();
		return new Function.prototype.$asyncbind.EagerThenable(boundThen);
	}

	if (catcher) {
		if (Function.prototype.$asyncbind.wrapAsyncStack) catcher = Function.prototype.$asyncbind.wrapAsyncStack(catcher);
		return then;
	}

	function then(result, error) {
		try {
			return result && result instanceof Object && typeof result.then === 'function' ? result.then(then, catcher) : resolver.call(self, result, error || catcher);
		} catch (ex) {
			return (error || catcher)(ex);
		}
	}

	function boundThen(result, error) {
		return resolver.call(self, result, error);
	}

	boundThen.then = boundThen;
	return boundThen;
};

/**
 * Creates a persistent storage file and handles interacting with the persistent
 * storage
 * @class LocalStorage
 * @param {string} fileName - The name of the persistent storage file. Will be json format
 */
class LocalStorage {
	constructor(fileName) {
		if (!fileName) throw new Error('You must provide a file name for the LocalStorage');

		/** @type {Object} */
		this._db = new _nodeJsonDb2.default(fileName, true, true);

		/** @type {Object} */
		this._temp = {};
	}

	/**
  * The number of keys in this storage
  * @memberof LocalStorage
  * @instance
  * @type {number}
  */
	get length() {
		try {
			let data = this._db.getData('/');
			return Object.keys(data).length || 0;
		} catch (err) {
			return 0;
		}
	}

	/**
  * The names of all keys in this storage
  * @memberof LocalStorage
  * @instance
  * @type {string[]}
  */
	get keys() {
		try {
			let data = this._db.getData('/');
			return Object.keys(data);
		} catch (err) {
			return [];
		}
	}

	/**
  * Get the name of the key at the given index in this storage
  * @memberof LocalStorage
  * @instance
  * @param {number} index - The index of the key to find
  * @returns {string}
  */
	key(index) {
		if (!index || index < 0) return null;
		try {
			let data = this._db.getData('/');
			if (index >= data.length) return null;
			return Object.keys(data)[index];
		} catch (err) {
			return null;
		}
	}

	/**
  * Get the value of the given key in this storage
  * @memberof LocalStorage
  * @instance
  * @param {string} key - The key of the item to get
  * @returns {*}
  */
	getItem(key) {
		if (typeof key !== 'string') return null;
		try {
			let data = this._db.getData(`/${ key }`);
			return JSON.parse(JSON.stringify(data));
		} catch (err) {
			return null;
		}
	}

	/**
  * Set the value of a given key in this storage
  * @memberof LocalStorage
  * @instance
  * @param {string} key - The key of the item to set
  * @param {*} value - The value to set
  */
	setItem(key, value) {
		if (typeof key !== 'string') return;
		if (typeof value === 'undefined') value = '';
		this._db.push(`/${ key }`, JSON.parse(JSON.stringify(value)), true);
	}

	/**
  * Delete an item in this storage
  * @memberof LocalStorage
  * @instance
  * @param {string} key - The key of the item to delete
  */
	removeItem(key) {
		if (typeof key !== 'string') return;
		this._db.delete(`/${ key }`);
	}

	/**
  * Check if key/value pair exists in this storage
  * @memberof LocalStorage
  * @instance
  * @param {string} key - The key of the item to check for
  * @returns {boolean}
  */
	exists(key) {
		if (typeof key !== 'string') return false;
		return this.getItem(key) !== null;
	}

	/**
  * Delete all items from this storage
  * @memberof LocalStorage
  * @instance
  */
	clear() {
		this._db.push('/', {}, true);
	}

	/**
  * Allow access to a storage item only when it is not currently being
  * accessed. Waits for other nonConcurrentAccess operations to finish
  * before proceeding with callback
  * @memberof LocalStorage
  * @instance
  * @param {string} key - the storage key you will be accessing
  * @param {function} callback - callback to execute that will be accessing the key
  * @returns {Promise}
  */
	queue(key, callback) {
		return new Promise((resolve, reject) => {
			try {
				while (this._temp[`checking${ key }`]) {} // eslint-disable-line
				this._temp[`checking${ key }`] = true;
				const finished = callback(key); // eslint-disable-line
				if (finished instanceof Promise) {
					finished.then(() => {
						delete this._temp[`checking${ key }`];
						resolve();
					}).catch(err => {
						delete this._temp[`checking${ key }`];
						reject(err);
					});
				} else {
					delete this._temp[`checking${ key }`];
					resolve();
				}
			} catch (err) {
				delete this._temp[`checking${ key }`];
				reject(err);
			}
		});
	}

	nonConcurrentAccess(key, callback) {
		console.warn('LocalStorage#nonConcurrentAccess has been deprecated and will be removed in a future update. Use LocalStorage#queue instead.');
		return this.queue(key, callback);
	}
}
exports.default = LocalStorage;