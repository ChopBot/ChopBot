'use babel';
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _discord = require('discord.js');

Function.prototype.$asyncbind = function anonymous(self, catcher) {
	var resolver = this;

	if (catcher === true) {
		if (!Function.prototype.$asyncbind.EagerThenable) Function.prototype.$asyncbind.EagerThenable = function factory(tick) {
			var _tasks = [];

			if (!tick) {
				try {
					tick = process.nextTick;
				} catch (ex) {
					tick = function tick(p) {
						setTimeout(p, 0);
					};
				}
			}

			function _untask() {
				for (var i = 0; i < _tasks.length; i += 2) {
					var t = _tasks[i + 1],
					    r = _tasks[i];

					for (var j = 0; j < t.length; j++) t[j].call(null, r);
				}

				_tasks = [];
			}

			function isThenable(obj) {
				return obj && obj instanceof Object && typeof obj.then === 'function';
			}

			function EagerThenable(resolver) {
				function done(inline) {
					var w;
					if (_sync || phase < 0 || (w = _thens[phase]).length === 0) return;

					_tasks.push(result, w);

					_thens = [[], []];
					if (_tasks.length === 2) inline ? _untask() : tick(_untask);
				}

				function resolveThen(x) {
					if (phase >= 0) return;
					if (isThenable(x)) return x.then(resolveThen, rejectThen);
					phase = 0;
					result = x;
					done(true);
				}

				function rejectThen(x) {
					if (phase >= 0) return;
					if (isThenable(x)) return x.then(resolveThen, rejectThen);
					phase = 1;
					result = x;
					done(true);
				}

				function settler(resolver, rejecter) {
					_thens[0].push(resolver);

					_thens[1].push(rejecter);

					done();
				}

				function toString() {
					return 'EagerThenable{' + {
						'-1': 'pending',
						0: 'resolved',
						1: 'rejected'
					}[phase] + '}=' + result.toString();
				}

				function guard() {
					try {
						resolver.call(null, resolveThen, rejectThen);
					} catch (ex) {
						rejectThen(ex);
					}
				}

				this.then = settler;
				this.toString = toString;
				var _thens = [[], []],
				    _sync = true,
				    phase = -1,
				    result;
				guard();
				_sync = false;
				done();
			}

			EagerThenable.resolve = function (v) {
				return isThenable(v) ? v : {
					then: function then(resolve, reject) {
						return resolve(v);
					}
				};
			};

			return EagerThenable;
		}();
		return new Function.prototype.$asyncbind.EagerThenable(boundThen);
	}

	if (catcher) {
		if (Function.prototype.$asyncbind.wrapAsyncStack) catcher = Function.prototype.$asyncbind.wrapAsyncStack(catcher);
		return then;
	}

	function then(result, error) {
		try {
			return result && result instanceof Object && typeof result.then === 'function' ? result.then(then, catcher) : resolver.call(self, result, error || catcher);
		} catch (ex) {
			return (error || catcher)(ex);
		}
	}

	function boundThen(result, error) {
		return resolver.call(self, result, error);
	}

	boundThen.then = boundThen;
	return boundThen;
};

/**
 * Stores all guild-specific storages as &lt;{@link string}, {@link GuildStorage}&gt; pairs,
 * where {@link string} is the guild's ID string
 * @class GuildStorageRegistry
 * @extends {external:Collection}
 */
class GuildStorageRegistry extends _discord.Collection {
	constructor() {
		super();
	}

	/**
  * Get the GuildStorage by [Guild]{@link external:Guild} or guild id string
  * @memberof GuildStorageRegistry
  * @instance
  * @param {(external:Guild|string)} guild - Guild object or guild id string
  * @returns {GuildStorage}
  */
	get(guild) {
		return super.get(guild.id ? guild.id : guild);
	}

	/**
  * Return a [Collection]{@link external:Collection} of GuildStorage items that
  * have the provided key and value
  * @memberof GuildStorageRegistry
  * @instance
  * @param {string} key - Setting key to match
  * @param {*} value - Value to match
  * @returns {external:Collection<string, GuildStorage>}
  */
	findAll(key, value) {
		return super.filter(a => a.getItem(key) === value);
	}

	/**
  * Return a [Collection]{@link external:Collection} of GuildStorage items that
  * have the provided setting key and value
  * @memberof GuildStorageRegistry
  * @instance
  * @param {string} key - Setting key to match
  * @param {*} value - Value to match
  * @returns {external:Collection<string, GuildStorage>}
  */
	findAllBySetting(key, value) {
		return super.filter(a => a.getSetting(key) === value);
	}

	/**
  * Reset all guild settings to default, deleting any extra settings that are
  * not part of the [DefaultGuildSettings]{@link DefaultGuildSettings}
  * @memberof GuildStorageRegistry
  * @instance
  * @param {DefaultGuildSettings} defaults - Should always use [DefaultGuildSettings]{@link DefaultGuildSettings}
  */
	resetAllGuildSettings(defaults) {
		super.forEach(guild => guild.resetSettings(defaults));
	}
}
exports.default = GuildStorageRegistry;